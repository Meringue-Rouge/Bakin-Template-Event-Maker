<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RPG Bakin Template Simulator</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .setting-box { border: 1px solid #000; padding: 10px; margin: 10px 0; background-color: #f9f9f9; }
        h1 { font-size: 24px; margin: 0 0 10px; }
        h2 { font-size: 18px; margin: 0 0 5px; }
        p { margin: 5px 0; }
        input[type="file"] { margin: 20px 0; }
        input[type="text"], input[type="number"], textarea { width: 100%; padding: 5px; margin-top: 5px; box-sizing: border-box; }
        textarea { height: 80px; resize: vertical; }
        label { display: block; margin-top: 10px; }
        #debug { white-space: pre-wrap; background-color: #f0f0f0; padding: 10px; margin-top: 20px; }
        button { margin-top: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #45a049; }
        .export-section { display: none; margin-top: 20px; }
        .export-section.visible { display: block; }
        .filename-input { width: 45%; display: inline-block; margin-right: 5%; }
        .filename-input:last-child { margin-right: 0; }
    </style>
</head>
<body>
    <h1>Upload RPG Bakin Template</h1>
    <input type="file" id="fileInput" accept=".txt">
    <div id="template-display"></div>
    <div id="exportSection" class="export-section">
        <label for="filenameId" class="filename-input">Filename ID (min 090000):</label>
        <label for="filenameString" class="filename-input">Filename String:</label>
        <input type="number" id="filenameId" value="090000" min="90000" class="filename-input">
        <input type="text" id="filenameString" placeholder="e.g., ending" class="filename-input">
        <button id="exportButton">Export File</button>
    </div>
    <div id="debug"></div>

    <script>
        // Global storage
        let originalLines = [];
        let editedValues = { title: '', description: '', settings: {} };

        // Debug logging
        const logDebug = message => document.getElementById('debug').textContent += message + '\n';

        // Type mapping based on word next to 設定ボックス
        const typeMap = {
            'キャラクターグラフィック': 'GRAPHICAL',
            '顔グラフィック': 'FACIAL GRAPHICS',
            '文章': 'MESSAGE',
            'モンスター': 'MONSTER',
            'アイテム': 'ITEM',
            'バトル背景': 'BATTLE BACKGROUND',
            '説明文': 'DESCRIPTION',
            '数値': 'INTEGER',
            'スイッチ': 'SWITCH'
        };

        // Command to template type mapping for generation
        const commandTypeMap = {
            'SWITCH': 'SWITCH',
            'ITEM': 'ITEM',
            'GRAPHIC': 'GRAPHICAL',
            'DIALOGUE': 'MESSAGE',
            'MONEY': 'INTEGER',
            'BOSSBATTLE': 'MONSTER'
        };

        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return logDebug('No file selected');
            const reader = new FileReader();
            reader.onload = e => {
                originalLines = e.target.result.split('\n');
                editedValues = { title: '', description: '', settings: {} };
                let template = parseTemplate(originalLines);
                if (!template.hasTemplate && template.eventName) {
                    const { generatedTemplate, modifiedLines } = generateTemplate(originalLines, template.eventName);
                    template = { ...generatedTemplate, hasTemplate: false, eventName: template.eventName };
                    originalLines = [...modifiedLines, ...originalLines];
                }
                displayTemplate(template);
                document.getElementById('exportSection').classList.add('visible');
                logDebug('File loaded and parsed');
            };
            reader.readAsText(file);
        });

        // Parse template
        function parseTemplate(lines) {
            let title = '', description = '', settingBoxes = [], currentBox = null, currentCategory = '';
            let hasTemplate = false, eventName = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('テンプレート定義') && !line.startsWith('テンプレート定義終了')) {
                    title = line.replace('テンプレート定義', '').trim() || 'Unnamed Template';
                    hasTemplate = true;
                    continue;
                }
                if (line.startsWith('イベント名')) {
                    eventName = line.replace('イベント名', '').trim();
                    continue;
                }
                if (line.startsWith('設定ボックス')) {
                    if (currentBox && currentBox.id) {
                        if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                        else settingBoxes.push(currentBox);
                    }
                    currentCategory = line.replace('設定ボックス', '').trim();
                    currentBox = { id: '', desc: '', defaultGuid: '', defaultString: '', defaultInteger: '', category: currentCategory, type: typeMap[currentCategory] || 'UNKNOWN' };
                    continue;
                }
                if (currentBox) {
                    if (line.startsWith('設定ID')) currentBox.id = line.replace('設定ID', '').trim();
                    else if (line.startsWith('説明')) currentBox.desc = line.replace('説明', '').trim();
                    else if (line.startsWith('デフォルトGuid')) currentBox.defaultGuid = line.replace('デフォルトGuid', '').trim();
                    else if (line.startsWith('デフォルト文字列')) currentBox.defaultString = line.replace('デフォルト文字列', '').trim();
                    else if (line.startsWith('デフォルト整数')) currentBox.defaultInteger = line.replace('デフォルト整数', '').trim();
                }
                if (line.startsWith('設定ボックス終了') && currentBox) {
                    if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                    else if (currentBox.id) settingBoxes.push(currentBox);
                    currentBox = null;
                    currentCategory = '';
                    continue;
                }
                if (line.startsWith('テンプレート定義終了')) {
                    if (currentBox) {
                        if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                        else if (currentBox.id) settingBoxes.push(currentBox);
                    }
                    break;
                }
            }

            return { title, description, settingBoxes, hasTemplate, eventName };
        }

        // Generate template for files without one
        function generateTemplate(lines, eventName) {
            if (!eventName) return { generatedTemplate: { title: '', description: '', settingBoxes: [] }, modifiedLines: [] };

            const settingBoxes = [];
            const modifiedLines = [...lines];
            let inScript = false, inSheet = false, lastComment = null, currentSheetStart = -1;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (line.startsWith('シート')) {
                    inSheet = true;
                    currentSheetStart = i;
                    continue;
                }
                if (line.startsWith('シート終了')) {
                    inSheet = false;
                    currentSheetStart = -1;
                    continue;
                }
                if (line.startsWith('スクリプト')) {
                    inScript = true;
                    continue;
                }
                if (line.startsWith('スクリプト終了')) {
                    inScript = false;
                    lastComment = null;
                    continue;
                }
                if (inScript && line.startsWith('コマンド\tCOMMENT')) {
                    if (i + 1 < lines.length && lines[i + 1].trim().startsWith('文字列')) {
                        const comment = lines[i + 1].replace('文字列', '').trim();
                        if (comment.startsWith('G#') || comment.startsWith('#')) {
                            lastComment = {
                                id: comment.slice(comment.startsWith('G#') ? 2 : 1).split(/\s+/)[0],
                                isGraphic: comment.startsWith('G#'),
                                lineIndex: i
                            };
                        }
                    }
                    continue;
                }
                if (inScript && lastComment) {
                    const commandLine = line.split(/\s+/).filter(part => part);
                    const commandType = commandLine[1] || '';
                    if (lastComment.isGraphic && commandType in commandTypeMap) {
                        // Handle G# for graphics
                        if (!settingBoxes.some(box => box.id === lastComment.id)) {
                            const box = {
                                id: lastComment.id,
                                desc: '',
                                defaultGuid: '',
                                defaultString: '',
                                defaultInteger: '',
                                category: 'キャラクターグラフィック',
                                type: 'GRAPHICAL'
                            };
                            // Look for existing graphic GUID in the sheet
                            for (let j = currentSheetStart; j < i && j >= 0; j++) {
                                if (modifiedLines[j].trim().startsWith('グラフィック')) {
                                    box.defaultGuid = modifiedLines[j].replace('グラフィック', '').trim();
                                    break;
                                }
                            }
                            settingBoxes.push(box);
                        }
                        // Update グラフィック field in the current sheet
                        for (let j = currentSheetStart; j < i && j >= 0; j++) {
                            if (modifiedLines[j].trim().startsWith('グラフィック')) {
                                modifiedLines[j] = `\tグラフィック\t|Guid|${lastComment.id}|`;
                                logDebug(`Updated グラフィック to |Guid|${lastComment.id}| at line ${j + 1}`);
                                break;
                            }
                        }
                        lastComment = null;
                    } else if (commandType === 'ITEM') {
                        // Handle # for items
                        if (!settingBoxes.some(box => box.id === lastComment.id)) {
                            const box = {
                                id: lastComment.id,
                                desc: '',
                                defaultGuid: '',
                                defaultString: '',
                                defaultInteger: '',
                                category: 'アイテム',
                                type: 'ITEM'
                            };
                            if (i + 1 < lines.length && lines[i + 1].trim().startsWith('Guid')) {
                                box.defaultGuid = lines[i + 1].replace('Guid', '').trim();
                            }
                            settingBoxes.push(box);
                        }
                        if (i + 1 < lines.length && lines[i + 1].trim().startsWith('Guid')) {
                            modifiedLines[i + 1] = `\t\tGuid\t|Guid|${lastComment.id}|`;
                            logDebug(`Updated ITEM Guid to |Guid|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    } else if (commandType === 'SWITCH') {
                        // Handle # for switches
                        if (!settingBoxes.some(box => box.id === lastComment.id)) {
                            const box = {
                                id: lastComment.id,
                                desc: '',
                                defaultGuid: '',
                                defaultString: '',
                                defaultInteger: '',
                                category: 'スイッチ',
                                type: 'SWITCH'
                            };
                            if (i + 1 < lines.length && lines[i + 1].trim().startsWith('整数')) {
                                box.defaultInteger = lines[i + 1].replace('整数', '').trim();
                            }
                            settingBoxes.push(box);
                        }
                        if (i + 1 < lines.length && lines[i + 1].trim().startsWith('変数')) {
                            modifiedLines[i + 1] = `\t\t変数\t"|文字列|${lastComment.id}|"`;
                            logDebug(`Updated SWITCH 変数 to |文字列|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    }
                }
            }

            const generatedLines = [
                `テンプレート定義\t${eventName}`,
                ...(settingBoxes.length ? settingBoxes.map(box => [
                    `\t設定ボックス\t${box.category}`,
                    `\t\t設定ID\t${box.id}`,
                    `\t\t説明\t${box.desc}`,
                    ...(box.defaultGuid ? [`\t\tデフォルトGuid\t${box.defaultGuid}`] : []),
                    ...(box.defaultString ? [`\t\tデフォルト文字列\t${box.defaultString}`] : []),
                    ...(box.defaultInteger ? [`\t\tデフォルト整数\t${box.defaultInteger}`] : []),
                    `\t設定ボックス終了`
                ].join('\n')) : []),
                `テンプレート定義終了`
            ].flat();

            return {
                generatedTemplate: {
                    title: eventName,
                    description: '',
                    settingBoxes
                },
                modifiedLines: generatedLines
            };
        }

        // Display template
        function displayTemplate({ title, description, settingBoxes }) {
            const displayDiv = document.getElementById('template-display');
            let html = `
                <label for="title-input">Template Title:</label>
                <input type="text" id="title-input" value="${title || ''}" onchange="updateField('title', this.value)">
                <label for="description-input">Template Description:</label>
                <textarea id="description-input" onchange="updateField('description', this.value)">${description || ''}</textarea>
            `;

            for (const box of settingBoxes) {
                const guidText = box.defaultGuid && !['GRAPHICAL', 'FACIAL GRAPHICS', 'ITEM', 'MONSTER', 'BATTLE BACKGROUND'].includes(box.type) ? ` (GUID: ${box.defaultGuid})` : '';
                html += `
                    <div class="setting-box">
                        <h2>[${box.type}]</h2>
                        <label for="id-input-${box.id}">Setting ID:</label>
                        <input type="text" id="id-input-${box.id}" value="${box.id}" onchange="updateField('settings.${box.id}.id', this.value)">
                        ${guidText ? `<p>${guidText}</p>` : ''}
                        ${box.type !== 'DESCRIPTION' ? `<label for="desc-input-${box.id}">Setting Description:</label><textarea id="desc-input-${box.id}" onchange="updateField('settings.${box.id}.desc', this.value)">${box.desc || ''}</textarea>` : ''}
                        ${renderInput(box.type, box)}
                    </div>
                `;
            }

            displayDiv.innerHTML = html || '<p>No valid template data found.</p>';
            logDebug(`Displayed ${settingBoxes.length} setting boxes`);
        }

        // Render input based on type
        function renderInput(type, box) {
            let html = '';
            if (['GRAPHICAL', 'FACIAL GRAPHICS', 'ITEM', 'MONSTER', 'BATTLE BACKGROUND'].includes(type)) {
                html += `<label for="guid-input-${box.id}">Edit GUID:</label><input type="text" id="guid-input-${box.id}" value="${box.defaultGuid || ''}" onchange="updateField('settings.${box.id}.guid', this.value)">`;
            }
            if (type === 'GRAPHICAL' && box.defaultString) {
                html += `<label for="anim-input-${box.id}">Animation Name:</label><input type="text" id="anim-input-${box.id}" value="${box.defaultString || ''}" onchange="updateField('settings.${box.id}.anim', this.value)">`;
            }
            if (type === 'MESSAGE' || type === 'SWITCH') {
                html += `<label for="string-input-${box.id}">${type === 'SWITCH' ? 'Switch Name' : 'Message Text'}:</label><textarea id="string-input-${box.id}" onchange="updateField('settings.${box.id}.string', this.value)">${box.defaultString || ''}</textarea>`;
            }
            if (type === 'INTEGER') {
                html += `<label for="int-input-${box.id}">Value:</label><input type="number" id="int-input-${box.id}" value="${box.defaultInteger || '0'}" onchange="updateField('settings.${box.id}.int', this.value)">`;
            }
            return html;
        }

        // Update field
        function updateField(path, value) {
            const keys = path.split('.');
            let obj = editedValues;
            for (let i = 0; i < keys.length - 1; i++) {
                obj = obj[keys[i]] = obj[keys[i]] || {};
            }
            obj[keys[keys.length - 1]] = value.trim();
            logDebug(`Updated ${path}: ${value}`);
        }

        // Export file
        function exportFile() {
            if (!originalLines.length) {
                logDebug('No original lines to export');
                alert('No file data available to export.');
                return;
            }

            const modifiedLines = [...originalLines];
            const idMapping = {};
            let inSettingBox = false, settingBoxLines = [], settingBoxStartIndex = 0;

            // Update setting boxes and track ID changes
            for (let i = 0; i < modifiedLines.length; i++) {
                let line = modifiedLines[i].trim();
                if (line.startsWith('テンプレート定義') && !line.startsWith('テンプレート定義終了')) {
                    if (editedValues.title) modifiedLines[i] = `テンプレート定義\t${editedValues.title}`;
                    continue;
                }
                if (line.startsWith('設定ボックス')) {
                    if (inSettingBox && settingBoxLines.length) {
                        updateSettingBox(modifiedLines, settingBoxLines, settingBoxStartIndex, idMapping);
                    }
                    inSettingBox = true;
                    settingBoxLines = [];
                    settingBoxStartIndex = i;
                }
                if (inSettingBox) settingBoxLines.push(modifiedLines[i]);
                if (line.startsWith('設定ボックス終了')) {
                    updateSettingBox(modifiedLines, settingBoxLines, settingBoxStartIndex, idMapping);
                    inSettingBox = false;
                    settingBoxLines = [];
                }
            }

            // Update script and sheet sections
            let inScript = false, inSheet = false, lastComment = null, currentSheetStart = -1;
            for (let i = 0; i < modifiedLines.length; i++) {
                let line = modifiedLines[i].trim();
                if (line.startsWith('シート')) {
                    inSheet = true;
                    currentSheetStart = i;
                    continue;
                }
                if (line.startsWith('シート終了')) {
                    inSheet = false;
                    currentSheetStart = -1;
                    continue;
                }
                if (line.startsWith('スクリプト')) {
                    inScript = true;
                    continue;
                }
                if (line.startsWith('スクリプト終了')) {
                    inScript = false;
                    lastComment = null;
                    continue;
                }
                if (inScript && line.startsWith('コマンド\tCOMMENT')) {
                    if (i + 1 < modifiedLines.length && modifiedLines[i + 1].trim().startsWith('文字列')) {
                        const comment = modifiedLines[i + 1].replace('文字列', '').trim();
                        if (comment.startsWith('G#') || comment.startsWith('#')) {
                            lastComment = {
                                id: comment.slice(comment.startsWith('G#') ? 2 : 1).split(/\s+/)[0],
                                isGraphic: comment.startsWith('G#')
                            };
                            lastComment.id = idMapping[lastComment.id] || lastComment.id;
                        }
                    }
                    continue;
                }
                if (inScript && lastComment) {
                    const commandLine = line.split(/\s+/).filter(part => part);
                    const commandType = commandLine[1] || '';
                    if (lastComment.isGraphic && inSheet) {
                        // Update グラフィック field
                        for (let j = currentSheetStart; j < i && j >= 0; j++) {
                            if (modifiedLines[j].trim().startsWith('グラフィック')) {
                                modifiedLines[j] = `\tグラフィック\t|Guid|${lastComment.id}|`;
                                logDebug(`Updated グラフィック to |Guid|${lastComment.id}| at line ${j + 1}`);
                                break;
                            }
                        }
                        lastComment = null;
                    } else if (commandType === 'ITEM') {
                        // Update ITEM Guid
                        if (i + 1 < modifiedLines.length && modifiedLines[i + 1].trim().startsWith('Guid')) {
                            modifiedLines[i + 1] = `\t\tGuid\t|Guid|${lastComment.id}|`;
                            logDebug(`Updated ITEM Guid to |Guid|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    } else if (commandType === 'SWITCH') {
                        // Update SWITCH 変数
                        if (i + 1 < modifiedLines.length && modifiedLines[i + 1].trim().startsWith('変数')) {
                            modifiedLines[i + 1] = `\t\t変数\t"|文字列|${lastComment.id}|"`;
                            logDebug(`Updated SWITCH 変数 to |文字列|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    }
                }
            }

            // Update other references for changed 設定ID
            for (let i = 0; i < modifiedLines.length; i++) {
                let line = modifiedLines[i];
                for (const [oldId, newId] of Object.entries(idMapping)) {
                    ['Guid', '文字列', '整数', '表情'].forEach(type => {
                        const pattern = `|${type}|${oldId}|`;
                        if (line.includes(pattern)) {
                            modifiedLines[i] = line.replace(pattern, `|${type}|${newId}|`);
                            logDebug(`Replaced ${pattern} with |${type}|${newId}| at line ${i + 1}`);
                        }
                    });
                }
            }

            const recreatedFile = modifiedLines.join('\n');
            logDebug('Exported file content:\n' + recreatedFile);

            // Get filename from inputs
            const filenameId = document.getElementById('filenameId').value || '090000';
            const filenameString = document.getElementById('filenameString').value.trim();
            const filename = filenameString ? `${filenameId}_${filenameString}.txt` : `${filenameId}.txt`;

            const blob = new Blob([recreatedFile], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert('File exported successfully!');
        }

        // Update setting box
        function updateSettingBox(lines, boxLines, startIndex, idMapping) {
            let settingId = '', newSettingId = '';
            let indices = { guid: -1, string: -1, desc: -1, int: -1, id: -1 };
            for (let j = 0; j < boxLines.length; j++) {
                const line = boxLines[j].trim();
                if (line.startsWith('設定ID')) {
                    settingId = line.replace('設定ID', '').trim();
                    indices.id = startIndex + j;
                }
                else if (line.startsWith('デフォルトGuid')) indices.guid = startIndex + j;
                else if (line.startsWith('デフォルト文字列')) indices.string = startIndex + j;
                else if (line.startsWith('説明')) indices.desc = startIndex + j;
                else if (line.startsWith('デフォルト整数')) indices.int = startIndex + j;
            }
            const settings = editedValues.settings[settingId] || {};
            if (settings.id && settings.id !== settingId) {
                idMapping[settingId] = newSettingId = settings.id;
                if (indices.id !== -1) {
                    lines[indices.id] = `\t設定ID\t${newSettingId}`;
                    logDebug(`Replaced 設定ID ${settingId} with ${newSettingId} at line ${indices.id + 1}`);
                }
            }
            if (settingId === '説明' && editedValues.description && indices.string !== -1) {
                lines[indices.string] = `\tデフォルト文字列\t${editedValues.description}`;
            } else {
                if (settings.guid && indices.guid !== -1) lines[indices.guid] = `\tデフォルトGuid\t${settings.guid}`;
                if (settings.desc && indices.desc !== -1) lines[indices.desc] = `\t説明\t${settings.desc}`;
                if (settings.string && indices.string !== -1) lines[indices.string] = `\tデフォルト文字列\t${settings.string}`;
                if (settings.anim && indices.string !== -1 && lines[startIndex].includes('キャラクターグラフィック')) lines[indices.string] = `\tデフォルト文字列\t${settings.anim}`;
                if (settings.int && indices.int !== -1) lines[indices.int] = `\tデフォルト整数\t${settings.int}`;
            }
        }

        // Attach export button event
        document.getElementById('exportButton').addEventListener('click', exportFile);
    </script>
</body>
</html>
