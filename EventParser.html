<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RPG Bakin Template Simulator</title>
    <style>
        /* General reset and typography */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        /* Headings */
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.75rem;
        }

        /* Paragraphs and text */
        p {
            margin-bottom: 0.5rem;
            color: #4a4a4a;
        }

        /* Inputs and textareas */
        input[type="text"],
        input[type="number"],
        textarea {
            width: 100%;
            padding: 12px;
            margin-top: 8px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background-color: #fff;
            font-size: 1rem;
            color: #333;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        textarea {
            height: 100px;
            resize: vertical;
        }

        /* File input */
        input[type="file"] {
            margin: 1.5rem 0;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background-color: #fff;
            cursor: pointer;
        }

        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 16px;
            background-color: #6366f1;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4f46e5;
        }

        /* Labels */
        label {
            display: block;
            margin-top: 1rem;
            font-size: 0.95rem;
            font-weight: 500;
            color: #2c3e50;
        }

        /* Buttons */
        button {
            margin-top: 1.5rem;
            padding: 12px 24px;
            background-color: #6366f1;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #4f46e5;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* Setting box */
        .setting-box {
            border: none;
            padding: 1.5rem;
            margin: 1rem 0;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: box-shadow 0.2s;
        }

        .setting-box:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Debug section */
        #debug {
            white-space: pre-wrap;
            background-color: #1a1a1a;
            color: #e5e7eb;
            padding: 1.5rem;
            margin-top: 2rem;
            border-radius: 12px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Export section */
        .export-section {
            display: none;
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .export-section.visible {
            display: block;
        }

        .filename-input {
            width: 48%;
            display: inline-block;
            margin-right: 4%;
        }

        .filename-input:last-child {
            margin-right: 0;
        }

        /* Help section */
        .help-section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .help-section h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #1a1a1a;
        }

        .help-section h2::after {
            content: '▼';
            font-size: 0.9rem;
            transition: transform 0.2s;
        }

        .help-section.collapsed h2::after {
            transform: rotate(-90deg);
        }

        .help-content {
            display: block;
            font-size: 0.95rem;
            color: #4a4a4a;
        }

        .help-section.collapsed .help-content {
            display: none;
        }

        .help-content ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .help-content ul li {
            margin-bottom: 0.5rem;
        }

        /* Responsive design */
        @media (max-width: 600px) {
            body {
                padding: 20px 15px;
            }

            h1 {
                font-size: 2rem;
            }

            .filename-input {
                width: 100%;
                margin-right: 0;
                margin-bottom: 1rem;
            }

            .setting-box {
                padding: 1rem;
            }

            .help-section {
                padding: 1rem;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Upload RPG Bakin Template</h1>
    <div class="help-section" id="helpSection">
        <h2>Help <span></span></h2>
        <div class="help-content">
            <p>This will let you convert any map event or common event into a Template Event, which can then be adjusted on the fly with parameters from the map. This will let you make more personalized events like a custom treasure chest event / door, without having to manually change every variable inside the event.</p>
            <h3>How to Use:</h3>
            <ul>
                <li>Create your event in Bakin as either a Map Event or Common Event. Test it out first to see if it is working as intended.</li>
                <li>Before exporting the event into a TXT file, you'll need to create "Note" (Comment) events just above the line of your event that you want the user to be able to modify through the UI. The text inside the comment must be formatted as #keyword, with keyword being anything you want. Only one comment per event line.</li>
                <li>If you create two comments with two different keywords for two different lines, it'll create two parameters in the UI.</li>
                <li>However, if you create two comments for two different lines but with the same keyword, it'll share the same UI for both those fields.</li>
                <li>Only in normal event sheets (not parallel sheets), you can create a comment line with G#keyword, keyword being the keyword of your choice, to allow the user to change the model/graphics of the event sheet. This only applies to the sheet it's on, share the same keyword on another sheet to replace multiple, use a different keyword to let the user change more than one event sheet graphic, etc.</li>
                <li>When everything's OK, export the txt and upload it on this website.</li>
                <li>Double-check that all the events are parsed with your keyword (same keywords only result in one field, this is normal).</li>
                <li>Fill in some descriptions, names, default GUIDs for graphics, etc.</li>
                <li>Before exporting the file, fill in the name and give it an ID over 090000. You can't have files with the same ID.</li>
                <li>Export and open your Bakin's Steamapps folder, located where your steam install is at.</li>
                <li>Go to Steam\steamapps\common\BAKIN\data\en if you use an English version of Bakin, or Steam\steamapps\common\BAKIN\data\jp for a Japanese version.</li>
                <li>For common events, drop it in the common_templates folder.</li>
                <li>For a map event, drop it in the templates folder.</li>
                <li>Make sure to add a bmp file with the exact same name as your txt file. Make a duplicate of one of the defaults in the same folder and rename it if you don't have one.</li>
                <li>Close Bakin entirely and then open a game project.</li>
                <li>For common events, it'll appear at the bottom when creating a standard common event. For a map event, it'll show up in a Event folder in the Events tab of placable entities.</li>
            </ul>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".txt">
    <div id="template-display"></div>
    <div id="exportSection" class="export-section">
        <label for="filenameId" class="filename-input">Filename ID (min 090000):</label>
        <label for="filenameString" class="filename-input">Filename String:</label>
        <input type="number" id="filenameId" value="090000" min="90000" class="filename-input">
        <input type="text" id="filenameString" placeholder="e.g., ending" class="filename-input">
        <button id="exportButton">Export File</button>
    </div>
    <div id="debug"></div>

    <script>
        // Global storage
        let originalLines = [];
        let editedValues = { title: '', description: '', settings: {} };

        // Debug logging
        const logDebug = message => document.getElementById('debug').textContent += message + '\n';

        // Type mapping based on word next to 設定ボックス
        const typeMap = {
            'キャラクターグラフィック': 'GRAPHICAL',
            '顔グラフィック': 'FACIAL GRAPHICS',
            '文章': 'MESSAGE',
            'モンスター': 'MONSTER',
            'アイテム': 'ITEM',
            'バトル背景': 'BATTLE BACKGROUND',
            '説明文': 'DESCRIPTION',
            '数値': 'INTEGER',
            'スイッチ': 'SWITCH'
        };

        // Command to template type mapping for generation
        const commandTypeMap = {
            'SWITCH': 'SWITCH',
            'ITEM': 'ITEM',
            'GRAPHIC': 'GRAPHICAL',
            'DIALOGUE': 'MESSAGE',
            'MONEY': 'INTEGER',
            'BOSSBATTLE': 'MONSTER'
        };

        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return logDebug('No file selected');
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    originalLines = e.target.result.split('\n');
                    editedValues = { title: '', description: '', settings: {} };
                    let template = parseTemplate(originalLines);
                    if (!template.hasTemplate && template.eventName) {
                        const { generatedTemplate, modifiedLines } = generateTemplate(originalLines, template.eventName);
                        template = { ...generatedTemplate, hasTemplate: false, eventName: template.eventName };
                        originalLines = [...modifiedLines, ...originalLines];
                        editedValues.title = generatedTemplate.title;
                    }
                    displayTemplate(template);
                    document.getElementById('exportSection').classList.add('visible');
                    logDebug('File loaded and parsed');
                } catch (error) {
                    logDebug(`Error processing file: ${error.message}`);
                    alert('Failed to process file. Check debug log.');
                }
            };
            reader.onerror = () => {
                logDebug('File reading failed');
                alert('Failed to read file.');
            };
            reader.readAsText(file);
        });

        // Parse template
        function parseTemplate(lines) {
            let title = '', description = '', settingBoxes = [], currentBox = null, currentCategory = '';
            let hasTemplate = false, eventName = '';
            let inSheet = false, sheetName = '', graphicGuid = '', motion = '';
            const graphicKeywords = new Map(); // Map to store G#keyword to sheet data

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('テンプレート定義') && !line.startsWith('テンプレート定義終了')) {
                    title = line.replace('テンプレート定義', '').trim();
                    hasTemplate = true;
                    continue;
                }
                if (line.startsWith('イベント名')) {
                    eventName = line.replace('イベント名', '').trim();
                    continue;
                }
                if (line.startsWith('シート')) {
                    inSheet = true;
                    sheetName = line.replace('シート', '').trim();
                    graphicGuid = '';
                    motion = '';
                    continue;
                }
                if (line.startsWith('シート終了')) {
                    inSheet = false;
                    sheetName = '';
                    continue;
                }
                if (inSheet && line.startsWith('グラフィック')) {
                    graphicGuid = line.replace('グラフィック', '').trim();
                    continue;
                }
                if (inSheet && line.startsWith('モーション')) {
                    motion = line.replace('モーション', '').trim();
                    continue;
                }
                if (inSheet && line.startsWith('コマンド\tCOMMENT')) {
                    if (i + 1 < lines.length && lines[i + 1].trim().startsWith('文字列')) {
                        const comment = lines[i + 1].replace('文字列', '').trim();
                        if (comment.startsWith('G#')) {
                            const keyword = comment.slice(2).split(/\s+/)[0];
                            if (keyword && graphicGuid && motion) {
                                // Store unique keywords with their sheet data
                                graphicKeywords.set(keyword, {
                                    sheetName,
                                    guid: graphicGuid,
                                    motion
                                });
                                logDebug(`Found G#${keyword} in sheet ${sheetName} with GUID ${graphicGuid} and motion ${motion}`);
                            }
                        }
                    }
                    continue;
                }
                if (line.startsWith('設定ボックス')) {
                    if (currentBox && (currentBox.id || currentBox.category === '説明文')) {
                        if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                        else settingBoxes.push(currentBox);
                    }
                    currentCategory = line.replace('設定ボックス', '').trim();
                    currentBox = {
                        id: '',
                        desc: '',
                        defaultGuid: '',
                        defaultString: '',
                        defaultInteger: '',
                        category: currentCategory,
                        type: typeMap[currentCategory] || 'UNKNOWN'
                    };
                    continue;
                }
                if (currentBox) {
                    if (line.startsWith('設定ID')) currentBox.id = line.replace('設定ID', '').trim();
                    else if (line.startsWith('説明')) currentBox.desc = line.replace('説明', '').trim();
                    else if (line.startsWith('デフォルトGuid')) currentBox.defaultGuid = line.replace('デフォルトGuid', '').trim();
                    else if (line.startsWith('デフォルト文字列')) currentBox.defaultString = line.replace('デフォルト文字列', '').trim();
                    else if (line.startsWith('デフォルト整数')) currentBox.defaultInteger = line.replace('デフォルト整数', '').trim();
                }
                if (line.startsWith('設定ボックス終了') && currentBox) {
                    if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                    else if (currentBox.id) settingBoxes.push(currentBox);
                    currentBox = null;
                    currentCategory = '';
                    continue;
                }
                if (line.startsWith('テンプレート定義終了')) {
                    if (currentBox) {
                        if (currentBox.category === '説明文') description = currentBox.defaultString || '';
                        else if (currentBox.id) settingBoxes.push(currentBox);
                    }
                    break;
                }
            }

            // Add graphic template boxes for G#keywords
            graphicKeywords.forEach(({ sheetName, guid, motion }, keyword) => {
                const box = {
                    id: keyword,
                    desc: `${sheetName} graphic`,
                    defaultGuid: guid,
                    defaultString: motion,
                    defaultInteger: '',
                    category: 'キャラクターグラフィック',
                    type: 'GRAPHICAL'
                };
                settingBoxes.push(box);
                editedValues.settings[keyword] = {
                    id: keyword,
                    desc: box.desc,
                    guid: guid,
                    string: motion,
                    int: '',
                    type: 'GRAPHICAL'
                };
                logDebug(`Added graphic template for keyword ${keyword} from sheet ${sheetName}`);
            });

            // Store parsed settings in editedValues
            editedValues.title = title || eventName || '';
            editedValues.description = description;

            return { title, description, settingBoxes, hasTemplate, eventName };
        }

        // Generate template for files without one
        function generateTemplate(lines, eventName) {
            if (!eventName) {
                editedValues.title = '';
                return { generatedTemplate: { title: '', description: '', settingBoxes: [] }, modifiedLines: [] };
            }

            const settingBoxes = [];
            const modifiedLines = [...lines];
            let inScript = false, inSheet = false, lastComment = null, currentSheetStart = -1;
            let sheetName = '', graphicGuid = '', motion = '';
            const graphicKeywords = new Map(); // Map to store G#keyword to sheet data

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (line.startsWith('シート')) {
                    inSheet = true;
                    sheetName = line.replace('シート', '').trim();
                    currentSheetStart = i;
                    graphicGuid = '';
                    motion = '';
                    continue;
                }
                if (line.startsWith('シート終了')) {
                    inSheet = false;
                    sheetName = '';
                    currentSheetStart = -1;
                    continue;
                }
                if (inSheet && line.startsWith('グラフィック')) {
                    graphicGuid = line.replace('グラフィック', '').trim();
                    continue;
                }
                if (inSheet && line.startsWith('モーション')) {
                    motion = line.replace('モーション', '').trim();
                    continue;
                }
                if (line.startsWith('スクリプト')) {
                    inScript = true;
                    continue;
                }
                if (line.startsWith('スクリプト終了')) {
                    inScript = false;
                    lastComment = null;
                    continue;
                }
                if (inScript && line.startsWith('コマンド\tCOMMENT')) {
                    if (i + 1 < lines.length && lines[i + 1].trim().startsWith('文字列')) {
                        const comment = lines[i + 1].replace('文字列', '').trim();
                        if (comment.startsWith('G#')) {
                            const keyword = comment.slice(2).split(/\s+/)[0];
                            if (keyword && graphicGuid && motion) {
                                graphicKeywords.set(keyword, {
                                    sheetName,
                                    guid: graphicGuid,
                                    motion
                                });
                                logDebug(`Found G#${keyword} in sheet ${sheetName} with GUID ${graphicGuid} and motion ${motion}`);
                                // Add to settingBoxes immediately
                                if (!settingBoxes.some(box => box.id === keyword)) {
                                    const box = {
                                        id: keyword,
                                        desc: `${sheetName} graphic`,
                                        defaultGuid: graphicGuid,
                                        defaultString: motion,
                                        defaultInteger: '',
                                        category: 'キャラクターグラフィック',
                                        type: 'GRAPHICAL'
                                    };
                                    settingBoxes.push(box);
                                    editedValues.settings[keyword] = {
                                        id: keyword,
                                        desc: box.desc,
                                        guid: graphicGuid,
                                        string: motion,
                                        int: '',
                                        type: 'GRAPHICAL'
                                    };
                                    logDebug(`Added graphic template for keyword ${keyword} from sheet ${sheetName}`);
                                }
                            }
                        }
                        if (comment.startsWith('G#') || comment.startsWith('#')) {
                            lastComment = {
                                id: comment.slice(comment.startsWith('G#') ? 2 : 1).split(/\s+/)[0],
                                isGraphic: comment.startsWith('G#'),
                                lineIndex: i
                            };
                        }
                    }
                    continue;
                }
                if (inScript && lastComment) {
                    const commandLine = line.split(/\s+/).filter(part => part);
                    const commandType = commandLine[1] || '';
                    if (lastComment.isGraphic && commandType in commandTypeMap) {
                        // Update グラフィック field in the current sheet
                        for (let j = currentSheetStart; j < i && j >= 0; j++) {
                            if (modifiedLines[j].trim().startsWith('グラフィック')) {
                                modifiedLines[j] = `\tグラフィック\t|Guid|${lastComment.id}|`;
                                logDebug(`Updated グラフィック to |Guid|${lastComment.id}| at line ${j + 1}`);
                                break;
                            }
                        }
                        lastComment = null;
                    } else if (commandType === 'ITEM') {
                        if (!settingBoxes.some(box => box.id === lastComment.id)) {
                            const box = {
                                id: lastComment.id,
                                desc: editedValues.settings[lastComment.id]?.desc || '',
                                defaultGuid: '',
                                defaultString: '',
                                defaultInteger: '',
                                category: 'アイテム',
                                type: 'ITEM'
                            };
                            if (i + 1 < lines.length && lines[i + 1].trim().startsWith('Guid')) {
                                box.defaultGuid = lines[i + 1].replace('Guid', '').trim();
                            }
                            settingBoxes.push(box);
                            editedValues.settings[box.id] = {
                                id: box.id,
                                desc: box.desc,
                                type: box.type,
                                guid: box.defaultGuid
                            };
                        }
                        if (i + 1 < lines.length && lines[i + 1].trim().startsWith('Guid')) {
                            modifiedLines[i + 1] = `\t\tGuid\t|Guid|${lastComment.id}|`;
                            logDebug(`Updated ITEM Guid to |Guid|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    } else if (commandType === 'SWITCH') {
                        if (!settingBoxes.some(box => box.id === lastComment.id)) {
                            const box = {
                                id: lastComment.id,
                                desc: editedValues.settings[lastComment.id]?.desc || '',
                                defaultGuid: '',
                                defaultString: '',
                                defaultInteger: '',
                                category: 'スイッチ',
                                type: 'SWITCH'
                            };
                            if (i + 1 < lines.length && lines[i + 1].trim().startsWith('整数')) {
                                box.defaultInteger = lines[i + 1].replace('整数', '').trim();
                            }
                            settingBoxes.push(box);
                            editedValues.settings[box.id] = {
                                id: box.id,
                                desc: box.desc,
                                int: box.defaultInteger,
                                type: box.type
                            };
                        }
                        if (i + 1 < lines.length && lines[i + 1].trim().startsWith('変数')) {
                            modifiedLines[i + 1] = `\t\t変数\t"|文字列|${lastComment.id}|"`;
                            logDebug(`Updated SWITCH 変数 to |文字列|${lastComment.id}| at line ${i + 2}`);
                        }
                        lastComment = null;
                    }
                }
            }

            // Update editedValues.title
            editedValues.title = eventName;

            // Include description and graphic templates in generated template
            const generatedLines = [
                `テンプレート定義\t${eventName}`,
                `\t設定ボックス\t説明文`,
                `\t\tデフォルト文字列\t${editedValues.description || ''}`,
                `\t設定ボックス終了`,
                ...(graphicKeywords.size ? Array.from(graphicKeywords.entries()).map(([keyword, { sheetName, guid, motion }]) => [
                    `\t設定ボックス\tキャラクターグラフィック`,
                    `\t\t設定ID\t${keyword}`,
                    `\t\t説明\t${sheetName} graphic`,
                    `\t\tデフォルトGuid\t${guid}`,
                    `\t\tデフォルト文字列\t${motion}`,
                    `\t設定ボックス終了`
                ].join('\n')) : []),
                ...(settingBoxes.filter(box => box.type !== 'GRAPHICAL').length ? settingBoxes.filter(box => box.type !== 'GRAPHICAL').map(box => [
                    `\t設定ボックス\t${box.category}`,
                    `\t\t設定ID\t${box.id}`,
                    `\t\t説明\t${box.desc}`,
                    ...(box.defaultGuid && box.type !== 'ITEM' ? [`\t\tデフォルトGuid\t${box.defaultGuid}`] : []),
                    ...(box.defaultString ? [`\t\tデフォルト文字列\t${box.defaultString}`] : []),
                    ...(box.defaultInteger ? [`\t\tデフォルト整数\t${box.defaultInteger}`] : []),
                    `\t設定ボックス終了`
                ].join('\n')) : []),
                `テンプレート定義終了`
            ].flat();

            return {
                generatedTemplate: {
                    title: eventName,
                    description: editedValues.description || '',
                    settingBoxes
                },
                modifiedLines: generatedLines
            };
        }

        // Display template
        function displayTemplate({ title, description, settingBoxes }) {
            const displayDiv = document.getElementById('template-display');
            let html = `
                <label for="title-input">Template Title:</label>
                <input type="text" id="title-input" value="${title || ''}" onchange="updateField('title', this.value)">
                <label for="description-input">Template Description:</label>
                <textarea id="description-input" onchange="updateField('description', this.value)">${description || ''}</textarea>
            `;

            settingBoxes.forEach(box => {
                html += `
                    <div class="setting-box">
                        <h2>[${box.type}]</h2>
                        <label for="id-input-${box.id}">Setting ID:</label>
                        <input type="text" id="id-input-${box.id}" value="${box.id}" onchange="updateField('settings.${box.id}.id', this.value)">
                        <label for="desc-input-${box.id}">Setting Description:</label>
                        <textarea id="desc-input-${box.id}" onchange="updateField('settings.${box.id}.desc', this.value)">${box.desc || ''}</textarea>
                        ${renderInput(box.type, box)}
                    </div>
                `;
            });

            displayDiv.innerHTML = html || '<p>No valid template data found.</p>';
            logDebug(`Displayed ${settingBoxes.length} setting boxes`);
        }

        // Render input based on type
        function renderInput(type, box) {
            let html = '';
            if (['GRAPHICAL', 'FACIAL GRAPHICS', 'MONSTER', 'BATTLE BACKGROUND'].includes(type)) {
                html += `
                    <label for="guid-input-${box.id}">Edit GUID:</label>
                    <input type="text" id="guid-input-${box.id}" value="${box.defaultGuid || ''}" onchange="updateField('settings.${box.id}.guid', this.value)">
                `;
            }
            if (type === 'GRAPHICAL') {
                html += `
                    <label for="string-input-${box.id}">Animation Name:</label>
                    <input type="text" id="string-input-${box.id}" value="${box.defaultString || ''}" onchange="updateField('settings.${box.id}.string', this.value)">
                `;
            }
            if (type === 'MESSAGE' || type === 'SWITCH') {
                html += `
                    <label for="string-input-${box.id}">${type === 'SWITCH' ? 'Switch Name' : 'Message Text'}:</label>
                    <textarea id="string-input-${box.id}" onchange="updateField('settings.${box.id}.string', this.value)">${box.defaultString || ''}</textarea>
                `;
            }
            if (type === 'INTEGER') {
                html += `
                    <label for="int-input-${box.id}">Value:</label>
                    <input type="number" id="int-input-${box.id}" value="${box.defaultInteger || '0'}" onchange="updateField('settings.${box.id}.int', this.value)">
                `;
            }
            return html;
        }

        // Update field
        function updateField(path, value) {
            const keys = path.split('.');
            let obj = editedValues;
            for (let i = 0; i < keys.length - 1; i++) {
                obj = obj[keys[i]] = obj[keys[i]] || {};
            }
            obj[keys[keys.length - 1]] = value.trim();
            logDebug(`Updated ${path}: ${value}`);
        }

        // Export file
        function exportFile() {
            if (!originalLines.length) {
                logDebug('No original lines to export');
                alert('No file data available to export.');
                return;
            }

            try {
                const modifiedLines = [...originalLines];
                const idMapping = {};
                let inSettingBox = false, settingBoxLines = [], settingBoxStartIndex = -1;

                // Update existing setting boxes and track ID changes
                for (let i = 0; i < modifiedLines.length; i++) {
                    let line = modifiedLines[i].trim();
                    if (line.startsWith('設定ボックス')) {
                        if (inSettingBox && settingBoxLines.length) {
                            updateSettingBox(modifiedLines, settingBoxLines, settingBoxStartIndex, idMapping);
                        }
                        inSettingBox = true;
                        settingBoxLines = [];
                        settingBoxStartIndex = i;
                    }
                    if (inSettingBox) settingBoxLines.push(modifiedLines[i]);
                    if (line.startsWith('設定ボックス終了')) {
                        updateSettingBox(modifiedLines, settingBoxLines, settingBoxStartIndex, idMapping);
                        inSettingBox = false;
                        settingBoxLines = [];
                    }
                }

                // Update script and sheet sections
                let inScript = false, inSheet = false, lastComment = null, currentSheetStart = -1;
                for (let i = 0; i < modifiedLines.length; i++) {
                    let line = modifiedLines[i].trim();
                    if (line.startsWith('シート')) {
                        inSheet = true;
                        currentSheetStart = i;
                        continue;
                    }
                    if (line.startsWith('シート終了')) {
                        inSheet = false;
                        currentSheetStart = -1;
                        continue;
                    }
                    if (line.startsWith('スクリプト')) {
                        inScript = true;
                        continue;
                    }
                    if (line.startsWith('スクリプト終了')) {
                        inScript = false;
                        lastComment = null;
                        continue;
                    }
                    if (inScript && line.startsWith('コマンド\tCOMMENT')) {
                        if (i + 1 < modifiedLines.length && modifiedLines[i + 1].trim().startsWith('文字列')) {
                            const comment = modifiedLines[i + 1].replace('文字列', '').trim();
                            if (comment.startsWith('G#') || comment.startsWith('#')) {
                                lastComment = {
                                    id: comment.slice(comment.startsWith('G#') ? 2 : 1).split(/\s+/)[0],
                                    isGraphic: comment.startsWith('G#')
                                };
                                lastComment.id = idMapping[lastComment.id] || lastComment.id;
                            }
                        }
                        continue;
                    }
                    if (inScript && lastComment) {
                        const commandLine = line.split(/\s+/).filter(part => part);
                        const commandType = commandLine[1] || '';
                        if (lastComment.isGraphic && inSheet) {
                            for (let j = currentSheetStart; j < i && j >= 0; j++) {
                                if (modifiedLines[j].trim().startsWith('グラフィック')) {
                                    modifiedLines[j] = `\tグラフィック\t|Guid|${lastComment.id}|`;
                                    logDebug(`Updated グラフィック to |Guid|${lastComment.id}| at line ${j + 1}`);
                                    break;
                                }
                            }
                            lastComment = null;
                        } else if (commandType === 'ITEM') {
                            if (i + 1 < modifiedLines.length && lines[i + 1].trim().startsWith('Guid')) {
                                modifiedLines[i + 1] = `\t\tGuid\t|Guid|${lastComment.id}|`;
                                logDebug(`Updated ITEM Guid to |Guid|${lastComment.id}| at line ${i + 2}`);
                            }
                            lastComment = null;
                        } else if (commandType === 'SWITCH') {
                            if (i + 1 < modifiedLines.length && lines[i + 1].trim().startsWith('変数')) {
                                modifiedLines[i + 1] = `\t\t変数\t"|文字列|${lastComment.id}|"`;
                                logDebug(`Updated SWITCH 変数 to |文字列|${lastComment.id}| at line ${i + 2}`);
                            }
                            lastComment = null;
                        }
                    }
                }

                // Update ID references
                for (let i = 0; i < modifiedLines.length; i++) {
                    let line = modifiedLines[i];
                    for (const [oldId, newId] of Object.entries(idMapping)) {
                        ['Guid', '文字列', '整数', '表情'].forEach(type => {
                            const pattern = `|${type}|${oldId}|`;
                            if (line.includes(pattern)) {
                                modifiedLines[i] = line.replace(pattern, `|${type}|${newId}|`);
                                logDebug(`Replaced ${pattern} with |${type}|${newId}| at line ${i + 1}`);
                            }
                        });
                    }
                }

                // Generate updated template section
                const settingBoxes = [];
                for (const id in editedValues.settings) {
                    const setting = editedValues.settings[id];
                    if (setting.id && setting.type && setting.type !== 'DESCRIPTION') {
                        const category = Object.keys(typeMap).find(key => typeMap[key] === setting.type) || 'UNKNOWN';
                        settingBoxes.push({
                            id: setting.id,
                            desc: setting.desc || '',
                            defaultGuid: setting.guid || '',
                            defaultString: setting.string || '',
                            defaultInteger: setting.int || '',
                            category: category,
                            type: setting.type
                        });
                    }
                }

                const newTemplateLines = [
                    `テンプレート定義\t${editedValues.title || ''}`,
                    `\t設定ボックス\t説明文`,
                    `\t\tデフォルト文字列\t${editedValues.description || ''}`,
                    `\t設定ボックス終了`,
                    ...(settingBoxes.length ? settingBoxes.map(box => [
                        `\t設定ボックス\t${box.category}`,
                        `\t\t設定ID\t${box.id}`,
                        `\t\t説明\t${box.desc}`,
                        ...(box.defaultGuid && box.type !== 'ITEM' ? [`\t\tデフォルトGuid\t${box.defaultGuid}`] : []),
                        ...(box.defaultString ? [`\t\tデフォルト文字列\t${box.defaultString}`] : []),
                        ...(box.defaultInteger ? [`\t\tデフォルト整数\t${box.defaultInteger}`] : []),
                        `\t設定ボックス終了`
                    ].join('\n')) : []),
                    `テンプレート定義終了`
                ].flat();

                // Replace or insert template section
                let templateStartIndex = -1, templateEndIndex = -1;
                for (let i = 0; i < modifiedLines.length; i++) {
                    let line = modifiedLines[i].trim();
                    if (line.startsWith('テンプレート定義') && !line.startsWith('テンプレート定義終了')) {
                        templateStartIndex = i;
                    }
                    if (line.startsWith('テンプレート定義終了') && templateStartIndex !== -1) {
                        templateEndIndex = i;
                        break;
                    }
                }

                if (templateStartIndex !== -1 && templateEndIndex !== -1 && templateEndIndex >= templateStartIndex) {
                    modifiedLines.splice(templateStartIndex, templateEndIndex - templateStartIndex + 1, ...newTemplateLines);
                    logDebug(`Replaced template section from line ${templateStartIndex + 1} to ${templateEndIndex + 1}`);
                } else {
                    let insertIndex = modifiedLines.findIndex(line => line.trim().startsWith('イベント名'));
                    if (insertIndex === -1) insertIndex = 0;
                    modifiedLines.splice(insertIndex, 0, ...newTemplateLines);
                    logDebug(`Inserted new template section at line ${insertIndex + 1}`);
                }

                const recreatedFile = modifiedLines.join('\n');
                logDebug('Exported file content:\n' + recreatedFile);

                // Get filename from inputs
                const filenameId = document.getElementById('filenameId').value || '090000';
                const filenameString = document.getElementById('filenameString').value.trim();
                const filename = filenameString ? `${filenameId}_${filenameString}.txt` : `${filenameId}.txt`;

                const blob = new Blob([recreatedFile], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('File exported successfully!');
            } catch (error) {
                logDebug(`Export failed: ${error.message}`);
                alert('Failed to export file. Check debug log for details.');
            }
        }

        // Update setting box
        function updateSettingBox(lines, boxLines, startIndex, idMapping) {
            let settingId = '', newSettingId = '';
            let indices = { guid: -1, string: -1, desc: -1, int: -1, id: -1 };
            for (let j = 0; j < boxLines.length; j++) {
                const line = boxLines[j].trim();
                if (line.startsWith('設定ID')) {
                    settingId = line.replace('設定ID', '').trim();
                    indices.id = startIndex + j;
                }
                else if (line.startsWith('デフォルトGuid')) indices.guid = startIndex + j;
                else if (line.startsWith('デフォルト文字列')) indices.string = startIndex + j;
                else if (line.startsWith('説明')) indices.desc = startIndex + j;
                else if (line.startsWith('デフォルト整数')) indices.int = startIndex + j;
            }
            const settings = editedValues.settings[settingId] || {};
            if (settings.id && settings.id !== settingId) {
                idMapping[settingId] = newSettingId = settings.id;
                if (indices.id !== -1) {
                    lines[indices.id] = `\t設定ID\t${newSettingId}`;
                    logDebug(`Replaced 設定ID ${settingId} with ${newSettingId} at line ${indices.id + 1}`);
                }
            }
            if (settingId === '説明' && editedValues.description && indices.string !== -1) {
                lines[indices.string] = `\tデフォルト文字列\t${editedValues.description}`;
            } else {
                if (settings.guid && indices.guid !== -1 && settings.type !== 'ITEM') lines[indices.guid] = `\tデフォルトGuid\t${settings.guid}`;
                if (settings.desc && indices.desc !== -1) lines[indices.desc] = `\t説明\t${settings.desc}`;
                if (settings.string && indices.string !== -1) lines[indices.string] = `\tデフォルト文字列\t${settings.string}`;
                if (settings.int && indices.int !== -1) lines[indices.int] = `\tデフォルト整数\t${settings.int}`;
            }
        }

        // Attach export button event
        document.getElementById('exportButton').addEventListener('click', exportFile);

        // Toggle help section
        document.getElementById('helpSection').addEventListener('click', function(event) {
            if (event.target.closest('h2')) {
                this.classList.toggle('collapsed');
            }
        });
    </script>
</body>
</html>
